{"config":{"indexing":"full","lang":["en","es"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Contexto Este paquete para Nodejs es una extensi\u00f3n de funcionalidades para objetos que se encargan de inter-process communication (IPC) . Un ejemplo de esto es ElectronJS con ipcMain , ipcRenderer y win.webContents , ya que con ellos se puede realizar la comunicaci\u00f3n del proceso principal con las distintas ventanas y viceversa. Importante La configuraci\u00f3n inicial funciona con ElectronJS por lo que para que funcione por ejemplo con NodeJS.ChildProcess , tendr\u00e1 que reimplementar _getArgsFromOn , _ipcNodeSend y colocar ipcNodeErrorObjectMode en true si quiere que tenga compatibilidad con IPCNodeError . Muy importante Este paquete utiliza Object.assign() . Todo en la interfaz IPCBaseNode se sobreescribe en el objeto que se registra con IPCNodeRegister.register . C\u00f3mo usarlo Lo primero es que debe registar su IPC, a este se le har\u00e1 un extensi\u00f3n con algunos m\u00e9todos que le pueden ser de utilidad, adem\u00e1s le permitir\u00e1 tener a su disponibilidad los IPC que registre en un scope global de ese proceso. Typescript/Javascript import { ipcMain } from \"electron\" ; import { IPCNodeRegister } from \"ipc-shell\" const ipc = IPCNodeRegister . register ( \"main\" , ipcMain ) Nota Se usar\u00e1 IpcMain como el tipo de IPC, si fuera para el ipcRenderer deber\u00eda usar IpcRenderer , para el ipc de win.webContents deber\u00eda usar WebContents , hablando en t\u00e9rminos de Electronjs, en general usar la clase del IPC que registra Chequeo de tipo La raz\u00f3n que se coloque el tipo es para que pueda obtener la extensi\u00f3n de los tipos sin tener errores antes de compilar si se est\u00e1 usando typescript, claro . A partir de ahora puede acceder en el mismo proceso a este IPC mediante su nombre: Typescript - Recomendado Typescript - Otro Javascript // somewhere else import { IpcMain } from \"electron\" ; import { IPCNodeRegister } from \"ipc-shell\" const ipc = IPCNodeRegister . get < IpcMain > ( \"main\" ); // somewhere else import { IpcMain } from \"electron\" ; import { IPCNodeRegister , IPCNode } from \"ipc-shell\" const ipc : IPCNode < IpcMain > = IPCNodeRegister . get ( \"main\" ); import { IpcMain } from \"electron\" ; import { IPCNodeRegister } from \"ipc-shell\" /** * @typedef {import(\"ipc-shell\").IPCNode} IpcNode * @typedef {import(\"electron\").IpcMain} IpcMain * * @type {IpcNode & IpcMain} */ const ipc = IPCNodeRegister . get ( \"main\" ); En el caso de Javascript se import\u00f3 los tipos y se les dio otro nombre con @typedef , as\u00ed que deber\u00e1 cambiar el tipo de IpcMain si es que usa JsDoc para sus tipos.","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#contexto","text":"Este paquete para Nodejs es una extensi\u00f3n de funcionalidades para objetos que se encargan de inter-process communication (IPC) . Un ejemplo de esto es ElectronJS con ipcMain , ipcRenderer y win.webContents , ya que con ellos se puede realizar la comunicaci\u00f3n del proceso principal con las distintas ventanas y viceversa. Importante La configuraci\u00f3n inicial funciona con ElectronJS por lo que para que funcione por ejemplo con NodeJS.ChildProcess , tendr\u00e1 que reimplementar _getArgsFromOn , _ipcNodeSend y colocar ipcNodeErrorObjectMode en true si quiere que tenga compatibilidad con IPCNodeError . Muy importante Este paquete utiliza Object.assign() . Todo en la interfaz IPCBaseNode se sobreescribe en el objeto que se registra con IPCNodeRegister.register .","title":"Contexto"},{"location":"#como-usarlo","text":"Lo primero es que debe registar su IPC, a este se le har\u00e1 un extensi\u00f3n con algunos m\u00e9todos que le pueden ser de utilidad, adem\u00e1s le permitir\u00e1 tener a su disponibilidad los IPC que registre en un scope global de ese proceso. Typescript/Javascript import { ipcMain } from \"electron\" ; import { IPCNodeRegister } from \"ipc-shell\" const ipc = IPCNodeRegister . register ( \"main\" , ipcMain ) Nota Se usar\u00e1 IpcMain como el tipo de IPC, si fuera para el ipcRenderer deber\u00eda usar IpcRenderer , para el ipc de win.webContents deber\u00eda usar WebContents , hablando en t\u00e9rminos de Electronjs, en general usar la clase del IPC que registra Chequeo de tipo La raz\u00f3n que se coloque el tipo es para que pueda obtener la extensi\u00f3n de los tipos sin tener errores antes de compilar si se est\u00e1 usando typescript, claro . A partir de ahora puede acceder en el mismo proceso a este IPC mediante su nombre: Typescript - Recomendado Typescript - Otro Javascript // somewhere else import { IpcMain } from \"electron\" ; import { IPCNodeRegister } from \"ipc-shell\" const ipc = IPCNodeRegister . get < IpcMain > ( \"main\" ); // somewhere else import { IpcMain } from \"electron\" ; import { IPCNodeRegister , IPCNode } from \"ipc-shell\" const ipc : IPCNode < IpcMain > = IPCNodeRegister . get ( \"main\" ); import { IpcMain } from \"electron\" ; import { IPCNodeRegister } from \"ipc-shell\" /** * @typedef {import(\"ipc-shell\").IPCNode} IpcNode * @typedef {import(\"electron\").IpcMain} IpcMain * * @type {IpcNode & IpcMain} */ const ipc = IPCNodeRegister . get ( \"main\" ); En el caso de Javascript se import\u00f3 los tipos y se les dio otro nombre con @typedef , as\u00ed que deber\u00e1 cambiar el tipo de IpcMain si es que usa JsDoc para sus tipos.","title":"C\u00f3mo usarlo"},{"location":"reference/","text":"Compatibilidad ChildProcess y Process Usuarios de Electronjs Si tu IPC es parte de esta librer\u00eda, estas modificaciones no te interesan. No eliminar el primer argumento ChildProcess y Process no tienen objectos antes de los mensajes, en el caso de Electron viene un argumento especial, por lo que la funci\u00f3n _getArgsFromOn remov\u00eda este de los argumentos para usar internamente, este comportamiento ya no es deseable. Despu\u00e9s regitrar su ipc (esto se hace por instancia) que es de tipo ChildProcess o Process debe realizar lo siguiente: Typescript Javascript ipc . _getArgsFromOn = function ( this : Process , ... args ) { return args } ipc . _getArgsFromOn = function (... args ) { return args } Lo anterior es para que no se elimine por defecto el primer argumento. Cuidado Esto es estrictamente necesario hacerlo despu\u00e9s de extender el objeto, ya que se sobreescriben las propiedades S\u00f3lo hay un \u00fanico canal En electron la funci\u00f3n send tambi\u00e9n recibe el nombre del canal por el que se va enviar, ChildProcess y Process s\u00f3lo cuentan con un \u00fanico canal, entonces debemos decirle que no use el par\u00e1metro del canal y que lo ingore: Typescript Javascript ipc . _ipcNodeSend = function ( this : Process | ChildProcess , _channel , message : Serializable ) { return this . send ? .( message ) } ipc . _ipcNodeSend = function ( message ) { return this . send ( message ) } Cuidado Esto es estrictamente necesario hacerlo despu\u00e9s de extender el objeto, ya que se sobreescriben las propiedades Habilitar la comprobaci\u00f3n de objetos para errores Electron tiene la capacidad de enviar Errores por el canal, sin embargo no contamos con esto ahora, entonces los errores son enviados como objetos, por lo que si quiere tener la caracter\u00edstica de errores de este paquete deber\u00e1 colocar lo siguiente: ipc . ipcNodeErrorObjectMode = true Cuidado Esto es estrictamente necesario hacerlo despu\u00e9s de extender el objeto, ya que se sobreescriben las propiedades","title":"Compatibilidad ChildProcess y Process"},{"location":"reference/#compatibilidad-childprocess-y-process","text":"Usuarios de Electronjs Si tu IPC es parte de esta librer\u00eda, estas modificaciones no te interesan.","title":"Compatibilidad ChildProcess y Process"},{"location":"reference/#no-eliminar-el-primer-argumento","text":"ChildProcess y Process no tienen objectos antes de los mensajes, en el caso de Electron viene un argumento especial, por lo que la funci\u00f3n _getArgsFromOn remov\u00eda este de los argumentos para usar internamente, este comportamiento ya no es deseable. Despu\u00e9s regitrar su ipc (esto se hace por instancia) que es de tipo ChildProcess o Process debe realizar lo siguiente: Typescript Javascript ipc . _getArgsFromOn = function ( this : Process , ... args ) { return args } ipc . _getArgsFromOn = function (... args ) { return args } Lo anterior es para que no se elimine por defecto el primer argumento. Cuidado Esto es estrictamente necesario hacerlo despu\u00e9s de extender el objeto, ya que se sobreescriben las propiedades","title":"No eliminar el primer argumento"},{"location":"reference/#solo-hay-un-unico-canal","text":"En electron la funci\u00f3n send tambi\u00e9n recibe el nombre del canal por el que se va enviar, ChildProcess y Process s\u00f3lo cuentan con un \u00fanico canal, entonces debemos decirle que no use el par\u00e1metro del canal y que lo ingore: Typescript Javascript ipc . _ipcNodeSend = function ( this : Process | ChildProcess , _channel , message : Serializable ) { return this . send ? .( message ) } ipc . _ipcNodeSend = function ( message ) { return this . send ( message ) } Cuidado Esto es estrictamente necesario hacerlo despu\u00e9s de extender el objeto, ya que se sobreescriben las propiedades","title":"S\u00f3lo hay un \u00fanico canal"},{"location":"reference/#habilitar-la-comprobacion-de-objetos-para-errores","text":"Electron tiene la capacidad de enviar Errores por el canal, sin embargo no contamos con esto ahora, entonces los errores son enviados como objetos, por lo que si quiere tener la caracter\u00edstica de errores de este paquete deber\u00e1 colocar lo siguiente: ipc . ipcNodeErrorObjectMode = true Cuidado Esto es estrictamente necesario hacerlo despu\u00e9s de extender el objeto, ya que se sobreescriben las propiedades","title":"Habilitar la comprobaci\u00f3n de objetos para errores"},{"location":"reference/readable/","text":"Readable (Stream) Puede crear un stream para recibir los datos de un canal en espec\u00edfico: const readable = ipc . readableStream ( \"notifications\" ) ipc . on ( \"data\" , ...) // ok! ipc . pipe (...) // ok! Lo que devuelve el m\u00e9todo es un stream.Readable , por lo que lo puede utilizar como tal (vea Readable ). Errores en Stream Cuando manda un IPCNodeError esto provoca que cualquier Readable (obtenido por .readableStream(channel) ), se cierre, por lo que ya no podr\u00e1 utilizarlo, esto es porque se emite el error, y por comportamiento de NodeJS, al obtener un error en un stream este ya no puede seguir usandose. Si quiere esperar un error puede hacerlo de la siguiente manera: ipc . on ( \"error\" , ( error ) => { ... }) Recuerde que s\u00f3lo puede utilizarse una vez por instancia obten\u00edda por .readableStream(channel) , luego de esto se puede subscribir al evento \"close\", para saber cu\u00e1ndo deja de funcionar el Stream.","title":"Readable (Stream)"},{"location":"reference/readable/#readable-stream","text":"Puede crear un stream para recibir los datos de un canal en espec\u00edfico: const readable = ipc . readableStream ( \"notifications\" ) ipc . on ( \"data\" , ...) // ok! ipc . pipe (...) // ok! Lo que devuelve el m\u00e9todo es un stream.Readable , por lo que lo puede utilizar como tal (vea Readable ). Errores en Stream Cuando manda un IPCNodeError esto provoca que cualquier Readable (obtenido por .readableStream(channel) ), se cierre, por lo que ya no podr\u00e1 utilizarlo, esto es porque se emite el error, y por comportamiento de NodeJS, al obtener un error en un stream este ya no puede seguir usandose. Si quiere esperar un error puede hacerlo de la siguiente manera: ipc . on ( \"error\" , ( error ) => { ... }) Recuerde que s\u00f3lo puede utilizarse una vez por instancia obten\u00edda por .readableStream(channel) , luego de esto se puede subscribir al evento \"close\", para saber cu\u00e1ndo deja de funcionar el Stream.","title":"Readable (Stream)"},{"location":"reference/send/","text":"Enviar errores La forma m\u00e1s sencilla de hacer esto es: ipc . sendError ( \"canal\" , \"oh no!\" ) El primer argumento es el canal por el cu\u00e1l se env\u00eda el error mientras que el sengundo es la informaci\u00f3n de error, puede ser objetos o lo que soporte su ipc.send . La otra forma es creando un IPCNodeError de forma manual y enviarlo por el m\u00e9todo que tenga disponible, por ejemplo en ElectronJS esto funciona igualmente: ipcNode . send ( \"canal\" , new IPCNodeError ( \"soy un error\" ))","title":"Enviar errores"},{"location":"reference/send/#enviar-errores","text":"La forma m\u00e1s sencilla de hacer esto es: ipc . sendError ( \"canal\" , \"oh no!\" ) El primer argumento es el canal por el cu\u00e1l se env\u00eda el error mientras que el sengundo es la informaci\u00f3n de error, puede ser objetos o lo que soporte su ipc.send . La otra forma es creando un IPCNodeError de forma manual y enviarlo por el m\u00e9todo que tenga disponible, por ejemplo en ElectronJS esto funciona igualmente: ipcNode . send ( \"canal\" , new IPCNodeError ( \"soy un error\" ))","title":"Enviar errores"},{"location":"reference/subscribe/","text":"Escuchar mensajes Otra forma para escuchar mensajes es utilizar el m\u00e9todo .subscribe(channel, handlers) que permite estar pendiente a mensajes normales y a los de error, a diferencia de los Streams este no dejar\u00e1 de funcionar aunque se envien errores, por lo que puede servir para otro tipo de enfoque. ipc . subscribe ( \"notifications\" , { handleData ( message ) { console . log ( \"from subscription\" , message ) }, handleError ( error ) { console . log ( \"from subscription error\" , error ) } }) ipc . subscribe ( \"channel-1\" , { handleData ( message1 , message2 ) { console . log ( \"from subscription m1\" , message1 ) console . log ( \"from subscription m2\" , message2 ) } }) ipc . subscribe ( \"channel-2\" , { handleError ( error ) { console . log ( \"from subscription error\" , error ) } }) ipc . subscribe ( \"channel-3\" , { handleData (... args ) { console . log ( \"from subscription\" , ... args ) } }) Si est\u00e1 en typescript puede serle de utilidad colocar los tipos, ya que por defecto son desconocidos unknown , la funci\u00f3n de error s\u00f3lo recibe un \u00fanico par\u00e1metro a pesar de su definici\u00f3n.","title":"Escuchar mensajes"},{"location":"reference/subscribe/#escuchar-mensajes","text":"Otra forma para escuchar mensajes es utilizar el m\u00e9todo .subscribe(channel, handlers) que permite estar pendiente a mensajes normales y a los de error, a diferencia de los Streams este no dejar\u00e1 de funcionar aunque se envien errores, por lo que puede servir para otro tipo de enfoque. ipc . subscribe ( \"notifications\" , { handleData ( message ) { console . log ( \"from subscription\" , message ) }, handleError ( error ) { console . log ( \"from subscription error\" , error ) } }) ipc . subscribe ( \"channel-1\" , { handleData ( message1 , message2 ) { console . log ( \"from subscription m1\" , message1 ) console . log ( \"from subscription m2\" , message2 ) } }) ipc . subscribe ( \"channel-2\" , { handleError ( error ) { console . log ( \"from subscription error\" , error ) } }) ipc . subscribe ( \"channel-3\" , { handleData (... args ) { console . log ( \"from subscription\" , ... args ) } }) Si est\u00e1 en typescript puede serle de utilidad colocar los tipos, ya que por defecto son desconocidos unknown , la funci\u00f3n de error s\u00f3lo recibe un \u00fanico par\u00e1metro a pesar de su definici\u00f3n.","title":"Escuchar mensajes"},{"location":"reference/writable/","text":"Writable (Stream) const writable = ipc . writableStream ( \"notifications\" ) writable . write ({ title : \"Good news\" , message : \"New cat :)\" }) Lo anterior crea un Stream de escritura, este cumple ser un stream.Writable (vea Writable ), que puede usar en vez de tener que utilizar ipc.send(\"channel\", \"informaci\u00f3n\") , esto le puede servir si tiene alg\u00fan tipo de servicio que sea stream.Readable o similares, y en vez de tener que subscribirse a \"data\", puede utilizar .pipe(writable) . Explicando el ejemplo lo que se est\u00e1 haciendo es enviando el objeto { title, message }, por el canal \"notifications\", este writable tiene la opci\u00f3n de mandar objetos, pero esto debe ser soportado de igual manera por la funci\u00f3n send del IPC. Errores Si quiere mandar un error utilice la clase IPCNodeError ya que esta es tratada de forma especial para las dem\u00e1s extensiones de este paquete.","title":"Writable (Stream)"},{"location":"reference/writable/#writable-stream","text":"const writable = ipc . writableStream ( \"notifications\" ) writable . write ({ title : \"Good news\" , message : \"New cat :)\" }) Lo anterior crea un Stream de escritura, este cumple ser un stream.Writable (vea Writable ), que puede usar en vez de tener que utilizar ipc.send(\"channel\", \"informaci\u00f3n\") , esto le puede servir si tiene alg\u00fan tipo de servicio que sea stream.Readable o similares, y en vez de tener que subscribirse a \"data\", puede utilizar .pipe(writable) . Explicando el ejemplo lo que se est\u00e1 haciendo es enviando el objeto { title, message }, por el canal \"notifications\", este writable tiene la opci\u00f3n de mandar objetos, pero esto debe ser soportado de igual manera por la funci\u00f3n send del IPC. Errores Si quiere mandar un error utilice la clase IPCNodeError ya que esta es tratada de forma especial para las dem\u00e1s extensiones de este paquete.","title":"Writable (Stream)"},{"location":"en/","text":"Information Cooming soon","title":"Information"},{"location":"en/#information","text":"Cooming soon","title":"Information"},{"location":"en/reference/","text":"...","title":"..."},{"location":"en/reference/#_1","text":"","title":"..."},{"location":"en/reference/readable/","text":"","title":"Readable"},{"location":"en/reference/send/","text":"","title":"Send"},{"location":"en/reference/subscribe/","text":"","title":"Subscribe"},{"location":"en/reference/writable/","text":"","title":"Writable"}]}